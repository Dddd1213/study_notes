# BI平台

[TOC]

# 01

## 需求分析

- 智能分析：用户输入目标，原始数据（excel），和图表类型，就能自动生成图表和分析结论
- 图表管理
- 图表生成异步化：**消息队列**！
- 对接AI



## 技术栈

- 前端
  - react，Umi 
  - Ant DesignPro
  - 可视化开发库 Echars+HighCharts+AntV
  - umi openapi 代码生成

- 后端
  - Spring Boot
  - MYSQL 数据库
  - Mybatis Plus
  - 消息队列 RabbitMQ
  - Open AI 接口开发
  - JDK 线程池及异步化
  - Excel 表格数据处理
  - Swagger + Knife4j接口文档生成
  - HuTool，Apache Common Util等工具库

## 前端项目初始化

- 注意：这里把node从v16.13.2切到了v18.16.0
  - nvm list 可以查看已经安装的版本
- ant Design pro报错可以去官方github的issues里搜搜看！
- 前端代码自动生成：根据后端生成的接口文档
  - 在config.ts的openapi里
  - 然后去package.json里面运行openapi
- 改后端的请求端口
  - baseURL

![image-20231110182615508](https://img2023.cnblogs.com/blog/3299940/202312/3299940-20231206170729312-424128528.png)

### 移除国计划指令报错

- yarn add eslint-config-prettier --dev
- yarn add eslint-plugin-unicorn --dev
- node_modules/@umijs/lint/dist/config/eslint/index.js
  // es2022: true



## 后端项目初始化

### 库表设计

#### 用户表user

#### 图表表chart

![image-20231108160851650](https://img2023.cnblogs.com/blog/3299940/202312/3299940-20231206170728504-1281088921.png)



## 用户基础功能

- 登录
- 注册
- 拦截器（拦截未登录用户）
- 全局异常处理器

### 创建和修改时自动计入时间

[mybatisPlus实现创建时间、更新时间自动添加_在创建时间和更改时间属性加一个什么注解,让他们分别只在增加和修改时间时生效_大城市里的小麻雀的博客-CSDN博客](https://blog.csdn.net/weixin_44774355/article/details/116302436?ops_request_misc=%7B%22request%5Fid%22%3A%22169949701616777224446989%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=169949701616777224446989&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-116302436-null-null.142^v96^pc_search_result_base2&utm_term=mybatisplus的save方法会自动获取当前时间吗&spm=1018.2226.3001.4187)



## chart基础功能

- 增加表
- 删除（仅本人和管理员可删除）



# 02

## 解决端口号占用问题

- 原因：windows hyper-V 虚拟化平台占用了端口
- cmd输入*netsh* *interface* *ipv4* *show* excludedportrange *protocol*=*tcp* 查看当前被占用的端口，避开这些就行



## 后端需求

- 用户输入
  - 分析目标
  - 上传原始数据（excel）
  - 控制图表类型，图表名称（可有可无）

- 后端校验
  - 校验用户输入的内容是否合法
  - 成本控制（次数统计和校验，鉴权）
- 把处理后的数据输给ai模型，ai提供图表信息和结论文本
- 图表信息（json）

## 开发接口

### 根据用户输入的文本和文件，返回图表信息和结论文本

- 图表压缩：ai有提问次数限制，尽量减少提问次数和字数（鱼聪明是两千多个token）
  - ai压缩
  - 人工压缩 csv

#### excel转csv

- easyexcel库
- 先读取数据，再转
- 原理其实就是把表头和数据读出来排列好，避免用冗杂的文字叙述



### 调用ai

#### 生成结论

- 输入：系统预设，分析目标，csv数据，图表类型
- 输出：BiVO，包括前端图表代码，和分析结论

#### 生成图表

- 无法生成图表？ -> 生成代码然后前端通过组件库生成图表



#### ai提问技巧

- 使用系统预设
- 控制输入格式
- 控制输出格式
- 指定示例问答



#### ai调用方式

- 调用官网（如openai）大模型的接口
- 鱼聪明：里面有写一些调用方式
  - https://github.com/liyupi/yucongming-java-sdk

```xml
<dependency>
    <groupId>com.yucongming</groupId>
    <artifactId>yucongming-java-sdk</artifactId>
    <version>0.0.2</version>
</dependency>
```



# 03

## 安全性问题

### 文件校验

- 文件大小（不能过大）
- 文件后缀
- 文件内容
- 文件合规性（敏感内容）（建议用第三方平台）
  - TODO：接入腾讯云的图片万象数据审核（COS对象存储功能）

### 数据存储

- 每个图标原始数据全部存储到了同一个数据表的字段里
  - 如果用户上传的文件太多，查询太慢
  - 用户如果想单独查询部分列的原始数据，就需要查出来那一块的全部内容，然后再进行条件过滤，会很麻烦
- 解决：把每个图表都单独存储
  - TODO：存到MongoDB中试试

### 限流

#### 本地限流（单机限流）

- Guava RateLimiter 

#### 分布式限流

- Ression：一个操作redis的数据网格
- 在网关进行集中统计



#### 限流的几种算法

- 参考这篇文章：[面试必备：4种经典限流算法讲解 - 掘金 (juejin.cn)](https://juejin.cn/post/6967742960540581918)
- 固定窗口
  - 单位时间允许部分用户操作
  - 0~1h（时刻）100人，1~2h（时刻）100人.....
  - 可能出现流量突刺（59min来了100个人，1h01min来了100个人，相当于服务器在2min内处理了200个操作）

- 滑动窗口
  - 指定一个滑动的窗口（如1h），指定滑动的周期（如5s），每隔5s窗口就往后滑动一格
  - 0~1h，0h20min~1h20min
  - 较难选择一个合适的滑动单位
- 漏桶限流（推荐）
  - 以固定的速率处理请求，当请求桶满了之后，拒绝请求
  - 没办法迅速处理一批请求
- 令牌桶（推荐）
  - 管理员以固定速率生成一批令牌；当用户要操作前，先去拿到一个令牌，有令牌的人就有资格同时进行操作，没令牌的就等着。
  - 优点：能并发处理同时的请求，并发性能会更高
  - 缺点：难以选择时间单位

#### 限流的粒度

- 针对方法限流
- 针对用户限流
- 针对某个用户x方法
- （直接用传入的key区分就行）



#### 这里使用Redisson进行限流

- redisson内置了一个限流工具类，可以帮助利用redis来存储统计



# 04

# 异步化

## 业务流程

- 用户点击提交时，立刻保存图表到数据库中（作为一个任务）
- 用户可以在图表管理页面查看所有图表信息和状态（排队中，生成中，已生成，生成失败）

### 优化

- guava Retrying重试
- 如果队列满了，可以用定时任务把失败状态的图表放到队列中（补偿）
- 定义状态为枚举
- 给任务定一个超时时间，超时自动标记失败
- 反向压力：比如通过ai服务的当前任务队列数来控制系统的核心线程数，从而最大化利用资源
- 任务执行成功/失败，给用户发个消息通知（websocket）

## 线程池

- 什么时候新增线程，什么时候减少空闲线程
- 作用：管理线程，协调任务的执行过程
- 实现：
  - spring中：ThreadPoolTaskExecutor配合@Async （不太建议）
  - java中：JUC并发编程包中ThreadPoolExecutor实现自定义线程池
- 确定线程池参数
  - 根据业务场景
  - 考虑系统瓶颈：eg. ai的并发只允许4个进程同时进行，20个任务排队，

- 参数

```java
corePoolSize – 核心线程数，固定员工
maximumPoolSize – 最大线程数，叫外包最大可达的员工数（根据瓶颈情况设置）
keepAliveTime – 非核心空闲线程最大等待时间，外包多久没活就得走
unit – keepAliveTime的时间单位
workQueue – 用于存放给线程执行的任务，存一个队列的长度
threadFactory – 控制线程的生成，线程的属性等
handler - 处理程序，当任务队列满的时候采取什么措施
```

- TODO：线程隔离策略：VIP单独一个线程池




## 线程池流程

- 来任务，先让核心线程处理；
- 核心线程处理不完的，放入任务队列
- 任务队列放满之后，再叫外包
- 任务队列满了，外包也满了，就调用handler拒绝策略

### 两种类型

- 计算密集型：比如音视频处理、图像处理、数学计算等，一般设置corePoolSize为CPU的核数+1
- IO密集型：吃带宽、内存、硬盘的读写资源，corePoolSize可以设置大一点，一般是2n+1



# 05

## 线程池的缺点

- 无法集中限制，只能单机限制
- 任务是存放在内存中执行的，可能会丢失
  - 虽然可以人工捞出来再重试，但是需要额外开发，很麻烦



## 消息队列

- 数据持久化：它可以把消息集中存储到硬盘，服务器重启不会丢失
- 可扩展性：可以通过需求增加或减少节点，继续保持稳定的服务
- 应用解耦：可以连接各个不同语言、框架开发的系统，让这些系统能够灵活地传输读取数据

![ae84f1236681d4c4e0b9dda6d61f51a](D:\flie\vx\WeChat Files\wxid_k6ct1pg6tzkg22\FileStorage\Temp\ae84f1236681d4c4e0b9dda6d61f51a.jpg)



## 消息队列缺点

- 引入额外的中间件，更复杂
- 消息丢失、顺序性、重复消费、数据的一致性



## Rabbit重要特性（面试考点）

- 消息队列的概念，模型，应用场景
- 交换机的类别，路由绑定关系
- 消息可靠性
  - 消息确认机制（ack，nack，reject）
  - 消息持久化（durable）
  - 消息过期机制
  - 死信队列
- 延迟队列
- 可扩展性
  - 集群
  - 故障的恢复机制
  - 镜像



# 06

## 功能补充和优化

- 使用redis缓存图表数据，提高图表的加载速度 √

- 使用死信队列处理异常情况，将异常图表任务置为失败 （好像实现了又没完全实现）
  - todo：写是写了但是它为啥不过期啊。。。
  - 服务器宕机之后那些信息会进入死信队列（也行。。）
  
- 线程池：给任务的执行增加一个超时时间，超时自动标记为失败（超时控制）√
  - 有个bug是它生成失败后线程无法终止，后面继续生成的结果还会覆盖掉前面的生成失败的内容，这里用手动判断了，很不优雅！！
  - 生成失败后线程好像终止了，用get看不到线程在运行

- 线程池：反向压力：https://zhuanlan.zhihu.com/p/404993753，通过调用的服务状态来选择当前系统的策略（比如根据 AI 服务的当前任务队列数来控制本系统的核心线程数），从而最大化利用系统资源。

- 看看rabbitmq使用线程池消费是怎么个事？ 

  - 但是线程池队列满了之后直接拒绝了然后卡在排队中的状态
  - 理想情况应该是线程池满了其他的先到消息队列等着，等线程池有空了再往里放，超时的消息过期

- **把分表数据存到Mongodb中**√

  - 参考HxBI
  - 这里就直接把chart插入了mongodb中，不在mysql中存储，减少mysql中存的数据量，加快mysql的查询速度

- **对接星火大模型**

- 任务执行成功/失败，给用户发个消息通知（websocket）√

- 积分制：

  - 每个用户每天可以领十个积分
  - 用redis存该用户今天是否已经领过积分，设置超时时间（怎么让时间0点刷新？）
  
  











# 07

# 完结撒花！













