# 设计模式

[TOC]

# 01

## 设计模式原则

### 开闭原则

- 扩展开放，修改关闭
- 使用抽象进行构建，面相抽象编程

### 依赖倒转原则

- 是开闭原则的基础
- 依赖抽象类而不是具体实现，减少耦合性

### 单一原则

- 一个类，接口，方法只负责单一职责

### 接口隔离原则

- 尽量细化接口，接口中的方法尽可能少

### 迪米特原则

- 一个对象应该对其他对象保持最小的了解
- （最小知道法则）

### 里氏替换原则

- 子类可以扩展的功能，不能修改父类原有的功能
- 子类不能覆盖父类原有的方法

### 合成复用原则

- 尽量使用对象组合、聚合的方式，而不是继承关系
- 减少一个类的变化对其他类的影响



# 02

# 创建者模式

- 怎样创建对象，将对象的创建和使用分离（解耦）

## 单例

### 懒汉式

- 在需要使用对象的时候才会创建

### 双重检查

- 考虑到并发问题，加一个同步锁

![image-20231118144955849](C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231118144955849.png)

### 静态内部类

- 通过私有的静态内部类，创建单例对象

### 饿汉式

- 类加载时就完成初始化
- （比如用个静态代码块）

### 枚举

- 通过枚举返回的都是单例的

### 序列化和反序列化破坏单例模式

- 通过流将单例对象序列化到文件中，然后反序列化取出来，会创建一个新的对象
- 这两个对象的地址不一致

### 通过反射破坏单例模式

- 通过字节码对象创建构造器对象
- 通过构造器对象，初始化单例对象



## 原型

- 创建对象的最佳方法
- 创建一个对象，创建第二个的时候用clone的方式创建而不是用new

## 工厂方法

- 一个CourseFactory父类（抽象类或者接口），里面写个getCourse方法
- 几个Factory子类，重写getCourse各创建各的对象
- 生成的都是相同系列的对象

## 抽象工厂

- 提供了创建一系列相关或互相依赖对象的接口
- eg. 生产汽车，把汽车分割为车架车门车盘三个抽象类，建三个对应的实现放大，然后在CarFactory中创建车架车门车盘

## 建造者

- 将复杂的对象的创建和属性赋值分离



# 03

# 结构型模式

- 描述如何将类或对象按某种布局组成更大的结构

## 代理

- 中介，重点在不暴露被代理的对象


## 适配器

- 作为两个不兼容接口之间的桥梁，将一个类的接口转换成客户希望的另一个接口
- （就是提供一个的play()方法，在里面加一个判断，如果是a就执行playA()，b就playB()）

## 桥接

- 用于把抽象化和实现化解耦


## 装饰

- 在原有类不被改变的前提下对内容进行附加，重点在功能的增强，也可调用被装饰的对象


## 外观

- 提供一个高层接口，用来访问里面子系统的一群接口，简化接口



## 享元

- 减少对象数量，从而改善应用所需的对象结构
- eg.
  - String 类型：内部维护了一个字符串对象池（即字符串常量池），相同的字符串只会在池中创建一次，之后它们会被多个对象共享，这样可以减少字符串对象的数量，降低内存的使用，并提升系统的效率。
  - Integer 类型：对常用的整数值（-127~128）进行了缓存，避免了每次创建新的 Integer 对象，提高了系统的性能。
  - 数据库连接池：数据库连接是非常消耗资源的，通过享元模式将连接池内部的连接对象进行复用，减少连接对象的创建和销毁，提高系统的效率和性能。
  - 线程池：通过享元模式将线程池中创建的线程对象进行复用，减少了线程的创建和销毁，从而提高系统的性能。

## **组合**

- 部分整体模式，用于把一组相似的对象当做一个单一的对象
- 依据树形结构来组合
- 创造一个包含自己对象组的类，该类提供了修改相同的对象组的方式
- eg. 员工类中封装了List<员工>表示它管理的员工下属，然后提供一些增加，删除下属等信息



# 04

# 行为型模式

- 用于描述类或对象之间怎样相互协作共同完成单个对象无法完成的任务，及怎样分配职责

## 模板方法

- 父类实现一个算法不变的部分，并将可变的控件留给子类完成

## 策略

- 避免使用大量if else
- 把方法准备好，传来什么就用什么方法
- （策略模式是将一整个流程给替换了, 而模板方法模式则是替换流程中部分特定内容）

## 命令

- 将请求封装成对象，实现请求的发送者和接收者之间的解耦，同时支持队列操作、日志记录和撤销操作。解耦调用者和行为实现者


## 职责链

- 一个发送者，一串接受者


## 状态

- 允许类在它的状态改变时改变它的行为


## 观察者

- 监听变化


## 中介者

- 提供一个中介对象，提供对象和对象间更便利的通信方式


## 迭代器

- 为遍历不同的集合结构提供了统一的接口，分离了集合对象的遍历行为


## 访问者

- 将数据结构和数据操作分离


## 备忘录

- 在不破坏封装的前提下获取一个对象的内部状态，并在该对象之外保存这个状态，“容错恢复”


## 解释器

- 通过给定的语言，定义它的语法和行为，并定义解释器






# 05

# 其他设计模式

## 简单工厂

- 只有一个CourseFrcatory，生产各种各样的对象

![image-20231117164744182](C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231117164744182.png)





