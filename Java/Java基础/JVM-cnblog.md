# JVM

[TOC]

# 01

# 初识JVM

## JVM的功能

- 跨平台的本质：不同操作系统上运行不同的jvm，能执行同一份字节码文件，生成机器指令，使翻译的机器指令在不同操作系统上运行结果相同

- 为什么不直接执行java文件？慢！

- 自动为对象，方法等分配内存；垃圾回收机制。
- 对热点代码进行优化，提升执行效率
  - 即时编译：将机器码保存至内存，直接调用

## JVM的位置

- 运行在操作系统（windows, Linux, Mac）上
- 操作系统在硬件（Inter，Spac...）上
- JVM的整体结构

![image-20231211205845954](C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231211205845954.png)

![image-20231211231954725](C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231211231954725.png)

## 字节码文件

- 魔数：文件的头几个字节，用来标识该文件的类型
- 版本号：主版本号 - 44（1.2以后）

![image-20231124121544632](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001446637-45536184.png)

- javap -v
  - 通过控制台查看字节码文件的内容
  - 后面加" > 路径名.文件名"，可以把生成的内容放在指定文件夹中

- arthas

  - 路径：D:\Software\Code下
  - 运行：java -jar arthas-boot.jar
  - dashboard
  - dump 类的全限定名：dump已加载类的字节码文件到特定目录

  - jad 类的全限定名：反编译已加载类的源码



# 02

## 类的生命周期

### 加载

- 类加载器：获取字节码信息
- java虚拟机：将字节码信息保存到**方法区**，里面有个引用地址指向堆区的对象
- java虚拟机：在**堆**里面生成一份与方法区中数据类似的java.lang.calss对象
  - 存放静态字段！
  - 只放了开发者可能需要访问的内容，提高数据的安全性
- 查看Java虚拟机内存信息
  - 使用JDK自带的hsdb工具；位于JDK安装目录下lib文件夹中的sa-jdi.jar中。
  - 启动命令：java -cp sa-jdi.jar sun.jvm.hotspot.HSDB
  - （打开cmd窗口，输入jps，可以看到java进程和进程id）

### 链接

- 验证：校验是否满足规范
  - 主版本号不能高于运行环境主版本号

- 准备：**给静态变量赋初值**（**默认值**，一般为0）
  - **如果是final修饰的基本数据类型的静态变量，则会在此时直接赋值**

- 解析：将常量池中的符号引用替换成指向内存的直接引用

### **初始化**

- **执行静态代码块中的代码**，并为**静态变量赋值**

  - 执行顺序和写的顺序是一致的

- 会触发初始化的情况

  - 访问一个类的静态变量或者静态方法

    - 注意变量是final修饰的并且等号右边是**常量**不会触发初始化。
    - final修饰的如果不是常量，而是需要通过赋值得出结果，也会执行初始化。

    <img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231124162949896.png" alt="image-20231124162949896" style="zoom:50%;" />

  - 调用Class.forName(String className)。

  - new一个该类的对象时。

  - **执行Main方法的当前类**

- **子类和父类**

  - 直接访问父类的静态变量，不会触发子类的初始化
  - 子类初始化调用之前，会先调用父类的初始化方法。

- 不会导致初始化的情况

  - **数组**的创建不会导致数组中元素的类进行初始化

- 打印出加载并初始化的类：

  ![image-20231124153324641](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001445755-356183021.png)

- 如下：会打印DACBCB

  - 含有main，所以先初始化，打印D
  - 打印A
  - 因为test类已经被加载过了，就不会被再次加载并初始化
  - 但是每次new都会触发构造器，C所在的代码块编译后也会放在构造方法中执行，且在B之前

  ![image-20231124153653608](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001445064-563734743.png)

### 使用

### 卸载



## 类加载器

- classLoader

<img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231124164318521.png" alt="image-20231124164318521" style="zoom:50%;" />



### 分类

- 虚拟机底层实现
  - 实现语言与虚拟机底层语言一致
  - 如启动类加载器BootStrap
- Java中的实现
  - java8：扩展类加载器Extension；应用程序加载器Application。
- 查看类加载器：打开arthas然后输入classloader

### 启动类加载器BootStrap

- 加载java安装目录jre/lib下的类文件
- 在程序中get类加载器get不到，因为这个在虚拟机底层实现不是在java中实现的

<img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231124170135178.png" alt="image-20231124170135178" style="zoom:45%;" />

<img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231124170325207.png" alt="image-20231124170325207" style="zoom:40%;" />

<img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231124170355948.png" alt="image-20231124170355948" style="zoom:40%;" />



<img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231124170411367.png" alt="image-20231124170411367" style="zoom:40%;" />

### Java中的默认类加载器

- 静态内部类，都继承自UrLClassLoader

- 扩展类加载器
  - 默认加载java安装目录/jre/lib/ext下的文件
  - 通用但不重要的文件
  - 如果路径中有空格等特殊字符，可以用引号引起来

<img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231124172342084.png" alt="image-20231124172342084" style="zoom:43%;" />

- 应用程序加载器Application
  - 加载classpath下的文件（当前项目中创建的类和maven依赖中包含的类）

- 显示某加载器加载的所有jar包

  ![image-20231124173008414](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001444210-2066920063.png)

## 双亲委派机制

- 解决类由谁加载的问题
- 作用：
  - 保证类加载的安全性
  - 避免重复加载
- ![image-20231124173329909](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001443427-1224182635.png)

## 打破双亲委派机制

- 自定义类加载器
  - 有相同限定名但是内容不同的类可能会被误判
  - tomcat解决：每个应用会有独立的类加载器加载对应的类
  - 自定义：主要通过继承ClassLoader然后重写loadClass的方法，删掉双亲委派机制的代码，自己设置加载路径的方式
- 线程上下文加载器
  - （听不懂）
- osgi框架的类加载器 
  - （了解）

## jdk 9 的变化

- 引入module
- ![image-20231124210840022](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001442832-113335264.png)

- ![image-20231124210853444](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001442244-1543161372.png)



# 03

# 运行时数据区

![image-20231125122837207](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001441482-1776997045.png)

## 程序计数器（PC寄存器）

- 记录当前要执行的字节码指令的地址

## Java虚拟机栈

- 管理方法调用中的基本数据，每一个方法的调用使用一个栈帧来保存

- 随线程创建而创建，销毁而销毁

- 栈帧：

  - 局部变量表：运行过程中的局部变量
    - 数组，槽slot，long和double占俩，其他占一个；
    - 在实例方法中，0号槽存放的是当前对象的引用this；
    - 存放当前方法的参数；
    - 当某个局部变量不再生效，当前槽就可以被再次使用（eg. 下面这题只有6个槽而不是9个）

  ![image-20231125133102086](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001440876-1542269019.png)

  - 操作数栈：存放临时数据

  - 帧数据：
    - 动态链接：当前类的字节码引用了其他类的属性或方法时，不会在类的连接阶段解析（将常量池中的符号引用替换成指向内存的直接引用），而是会将引用存入到运行时商量池中。
    - 方法出口：在自己的栈帧中存放的（下一个方法）下一步需要执行的地址
    - 异常表：主要包含trycatch执行后跳转的字节码位置

- 内存溢出：如果栈帧过多，就可能出现StackOverflowError
  - -Xss 栈大小：可以设置栈的大小（在运行设置，添加java虚拟机参数）
  - hotSpot：栈最小180k，最大1024m

## 本地方法栈

- 在hotSpot中，java虚拟机栈和本地方法栈使用了同一个栈空间

## 堆

- 创建出来的对象都在堆上
- ![image-20231125164345892](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001440172-1844680337.png)

- 堆空间：内存溢出（并不是used=max=total时溢出）
  - used：当前已使用的
  - total：已分配的可用内存
  - max：最大分配内存
- 自定义内存
  - -Xms 内存大小：设置初始total，必须大于1MB
  - -Xmx 内存大小：设置max最大值（一般用kb，mb...），必须大于2MB
  - （一般把两者设置成一样的值）

## 方法区

### 类的元信息

- 类的加载过程中完成

### 运行时常量池

- 通过内存地址定位常量池中内容

- 加载+连接完成
- 前：静态常量池（通过编号查找方式找到常量）

- 字符串常量池

- 实现

  - java8以前：存放在堆区域中的永久代空间
  - java8以后：操作系统维护的直接内存中

- ByteBody

  ![image-20231125184144872](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001439616-1765407917.png)

-  -XX:MaxPermSize=值
  - 设置元空间大小，一般256M就够了

### 字符串常量池

- ![image-20231125184643079](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001438969-191847373.png)

- String.intern()：手动将字符串放入字符串常量池中

- 结果是true，false

![image-20231125185638855](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001438133-924347725.png)

- 位置
  - jdk6及以前：存放在方法区（永久代中）
  - jdk7及以后：存放在堆中



## 直接内存

- ![image-20231125190409988](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001437633-916272033.png)

- -XX:MaxDirectMemorySize=大小

- <img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231125191109402.png" alt="image-20231125191109402" style="zoom:50%;" />

- <img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231125191159602.png" alt="image-20231125191159602" style="zoom:50%;" />
- jdk8<img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231125191129189.png" alt="image-20231125191129189" style="zoom:50%;" />



# 04

# 自动垃圾回收

## 方法区的回收

- 此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。
- 加载该类的类加载器已经被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用。



## 堆回收

- 无法通过引用获取到该对象时
  - 引用计数法：无法解决循环引用
  - 可达性分析法：GC Root（根对象）
    - 线程Thread对象，引用线程栈帧中的方法参数、局部变量等。
    - 系统类加载器加载的java.lang.Class对象，引用类中的静态变量。
    - 监视器对象，用来保存同步锁synchronized关键字持有的对象。
    - 本地方法调用时使用的全局对象。
  - -verbose:gc  查看垃圾回收日志
- heapdump 路径名
  - 保存堆内存快照到指定路径
- MemoryAnalyzer：查看GC Root的工具

### 五种不同的对象引用

- 强引用（如上）
- 软引用：程序内存不足时就会回收；常用于缓存；
- 弱引用：垃圾回收时会被回收掉，一般在ThreadLoal中使用；
- 虚引用：不能通过它拿到里面的对象；唯一的作用是当对象被垃圾回收时会收到通知；
- 终结器引用



### 垃圾回收算法

- STW：垃圾回收时阻塞其他线程的时间

#### 评价标准

- 吞吐量
- 最大暂停时间
- 堆使用效率
- （不可兼得，不同的算法适用于不同场景）

#### 标记-清除算法

- 实现：
  - 对存活的对象进行标记
  - 清除未标记对象
- 缺点：
  - 碎片化问题
  - 分配速度慢，需要维护空闲链表

#### 复制算法

- 实现
  - from空间和to空间
  - 垃圾回收阶段，把from的对象转移到to
  - 回收from
  - 然后把from和to名称互换
- 优点
  - 吞吐量高
  - 不会碎片化
- 缺点：
  - 内存使用率低

#### 标记整理算法

- 实现：

  - 标记：标记存活的对象
  - 整理：将存活的移到一端

  ![image-20231125215449191](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001437142-769668656.png)

- 优点
  - 内存使用率高
  - 不会碎片化
- 缺点
  - 整理阶段效率不高

#### 分代垃圾回收算法

- ![image-20231125215927133](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001436689-813116241.png)

- -XX:+UseSerialGC，使用分代回收的垃圾回收器
- ![image-20231125220041052](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001436101-1714840585.png)

- 分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。
  随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC。
  Minor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。
- 接下来，SO会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC.
  此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入SO。
  注意:每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。
- 当年龄到达一定值（最大15），就会被晋升到老年代
- 另：如果年轻代垃圾回收之后还是满的，也会将一些对象放入老年代
- 如果老年代满了，先进行Minor GC年轻代的回收，再进行FULL GC整个堆的回收

- 新生代一般选择复制算法，老年代可以选择标记清除或标记整理

### 垃圾回收器

#### 垃圾回收器1

![image-20231125233602231](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001435383-1355935658.png)

- 年轻代 - serial垃圾回收器
  - 单线程串行回收

![image-20231125233447589](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001434881-1113686807.png)

- 老年代：SerialOld垃圾回收器
  - 标记整理算法
  - 串行回收
  - 优缺点同上

#### 垃圾回收器2

![image-20231125233936703](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001434438-2075529696.png)

- 年轻代 - ParNew

  - 多线程进行垃圾回收

  ![image-20231125235324854](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001434010-1324506173.png)

![image-20231125234037039](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001433467-123480082.png)

- 老年代 - CMS

![image-20231125234240187](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001433008-796456138.png)

![image-20231125234230876](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001432513-1690219248.png)

#### 垃圾回收器3

![image-20231125235402300](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001431984-1169892505.png)

![image-20231125235525996](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001431216-483999609.png)

![image-20231125235643681](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001430447-541501491.png)

#### ！G1垃圾回收器

- jdk9之后默认使用

- 内存结构：

  - 被划分为大小相等的区（region）

    <img src="C:\Users\31067\AppData\Roaming\Typora\typora-user-images\image-20231126000133001.png" alt="image-20231126000133001" style="zoom:50%;" />

- 回收方式
  - 年轻代回收
  - 混合回收

- 执行
  - **选择**某些区域进行回收（根据最大暂停时间和每个区域的平均耗时）

![image-20231126000518130](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001429684-1457717571.png)

![image-20231126000709484](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001429107-775762386.png)

![image-20231126000730504](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001428667-82816174.png)

![image-20231126000741922](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001428103-1422525441.png)

- 混合回收的流程
  - 对老年代的清理会先处理存活度最低的区域

![image-20231126000931343](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001427440-148065630.png)

- 如果都满了，就会Full GC

- 使用

  ![image-20231126001107304](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001426252-698378678.png)

![image-20231126001118512](https://img2023.cnblogs.com/blog/3299940/202311/3299940-20231126001425605-306518996.png)